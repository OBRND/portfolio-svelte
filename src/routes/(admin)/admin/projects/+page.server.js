import { supabaseServer } from "$lib/server/supabase.js"
import { error, fail } from "@sveltejs/kit"

/**
 * Helper function to safely parse potential JSON strings into arrays.
 * Handles cases where arrays might be stored as TEXT[] or JSONB strings.
 */
function safeParseJsonArray(input) {
  if (Array.isArray(input)) {
    return input; // Already an array (e.g., if Supabase returns TEXT[] directly)
  }
  if (typeof input === 'string') {
    try {
      const parsed = JSON.parse(input);
      // Ensure the parsed result is an array; otherwise, wrap it.
      return Array.isArray(parsed) ? parsed : [parsed];
    } catch (e) {
      // If JSON.parse fails, assume it's a comma-separated string
      return input.split(',').map(item => item.trim()).filter(item => item.length > 0);
    }
  }
  return []; // Default fallback for null or other types
}

/** @type {import('./$types').PageServerLoad} */
export async function load() {
  try {
    console.log("Admin: Loading projects...")

    // Fetch all projects
    const { data: projects, error: supabaseError } = await supabaseServer
      .from("projects")
      .select("*")
      .order("orders", { ascending: false }) // Still order by orders for display

    if (supabaseError) {
      console.error("Admin: Supabase error:", supabaseError)
      throw error(500, `Failed to fetch projects: ${supabaseError.message}`)
    }

    // Processed projects for client-side use.
    // Use 'orders' as the 'id' for client-side representation, as it's the primary key.
    const processedProjects = (projects || []).map((project) => ({
      ...project,
      // 'orders' is the primary key, so it should always be present and unique for existing projects.
      id: project.orders, // Use orders as the client-side ID
      tags: safeParseJsonArray(project.tags),
      technologies: safeParseJsonArray(project.technologies),
    }))

    console.log(`Admin: Loaded ${processedProjects.length} projects`)

    return {
      projects: processedProjects,
      tableName: "projects", // Assuming "projects" is the table name
    }
  } catch (err) {
    console.error("Admin: Load error:", err)
    throw error(500, `Failed to load admin page: ${err.message}`)
  }
}

export const actions = {
  create: async ({ request }) => {
    try {
      const formData = await request.formData()

      // Extract and validate form data
      const title = formData.get("title")?.toString().trim()
      const subtitle = formData.get("subtitle")?.toString().trim()
      const description = formData.get("description")?.toString().trim()
      const image_link = formData.get("image_link")?.toString().trim()
      const source_link = formData.get("source_link")?.toString().trim()
      const year = Number(formData.get("year")?.toString() || new Date().getFullYear().toString())
      // 'orders' for create should either be generated by DB (if serial/identity)
      // or provided unique by client (if it's the primary key). Assuming the latter for now.
      const orders = Number(formData.get("orders")?.toString() || "0") 

      // Parse arrays (assuming TEXT[] in Supabase, so no JSON.stringify here)
      const tagsInput = formData.get("tags")?.toString().trim() || ""
      const techInput = formData.get("technologies")?.toString().trim() || ""

      const tags = tagsInput
        ? tagsInput
            .split(",")
            .map((t) => t.trim())
            .filter((t) => t.length > 0)
        : []
      const technologies = techInput
        ? techInput
            .split(",")
            .map((t) => t.trim())
            .filter((t) => t.length > 0)
        : []

      // Basic validation for required fields and numbers
      if (!title) {
        return fail(400, { error: true, message: "Title is required." })
      }
      if (isNaN(year)) {
        return fail(400, { error: true, message: "Year must be a valid number." })
      }
      if (isNaN(orders)) {
        return fail(400, { error: true, message: "Orders must be a valid number." })
      }
      // If 'orders' is the primary key and it's not auto-generated,
      // you might need to add a check for uniqueness here before inserting.

      // Insert new project
      const { data, error: insertError } = await supabaseServer
        .from('projects')
        .insert({
          title,
          subtitle: subtitle || null,
          description: description || null,
          image_link: image_link || null,
          source_link: source_link || null,
          year,
          orders, // Insert 'orders' value as primary key
          tags: tags,
          technologies: technologies,
        })
        .select()

      if (insertError) {
        console.error("Create error:", insertError)
        return fail(500, { error: true, message: `Failed to create project: ${insertError.message}` })
      }

      console.log("Project created successfully:", data)
      return { success: true, message: "Project created successfully!", project: data[0] }
    } catch (err) {
      console.error("Create action error:", err)
      return fail(500, { error: true, message: `An unexpected error occurred: ${err.message}` })
    }
  },

  update: async ({ request }) => {
    try {
      const formData = await request.formData()

      // The 'id' from formData now represents the 'orders' primary key value
      const clientOrdersId = formData.get("id")?.toString()
      const title = formData.get("title")?.toString().trim()
      const subtitle = formData.get("subtitle")?.toString().trim()
      const description = formData.get("description")?.toString().trim()
      const image_link = formData.get("image_link")?.toString().trim()
      const source_link = formData.get("source_link")?.toString().trim()
      const year = Number(formData.get("year")?.toString() || new Date().getFullYear().toString())
      const orders = Number(formData.get("orders")?.toString() || "0") // The new 'orders' value (could be same or changed)

      // Parse arrays
      const tagsInput = formData.get("tags")?.toString().trim() || ""
      const techInput = formData.get("technologies")?.toString().trim() || ""

      const tags = tagsInput
        ? tagsInput
            .split(",")
            .map((t) => t.trim())
            .filter((t) => t.length > 0)
        : []
      const technologies = techInput
        ? techInput
            .split(",")
            .map((t) => t.trim())
            .filter((t) => t.length > 0)
        : []

      // Validation for the 'orders' value used as primary key
      if (!clientOrdersId) {
          return fail(400, { error: true, message: "Project ID (orders) is required for update." });
      }
      const dbOrdersId = Number(clientOrdersId); // Convert to number for DB query
      if (isNaN(dbOrdersId)) {
          return fail(400, { error: true, message: "Invalid project ID (orders) format. Must be a number." });
      }
      if (isNaN(year)) {
        return fail(400, { error: true, message: "Year must be a valid number." })
      }
      if (isNaN(orders)) {
        return fail(400, { error: true, message: "Orders must be a valid number." })
      }

      // Update project by 'orders' primary key
      const { data, error: updateError } = await supabaseServer
        .from("projects")
        .update({
          title,
          subtitle: subtitle || null,
          description: description || null,
          image_link: image_link || null,
          source_link: source_link || null,
          year,
          orders, // Update the orders value in the row (if changed)
          tags: tags,
          technologies: technologies,
        })
        .eq("orders", dbOrdersId) // FIX: Use 'orders' for filtering
        .select()

      if (updateError) {
        console.error("Update error:", updateError)
        return fail(500, { error: true, message: `Failed to update project: ${updateError.message}` })
      }

      if (!data || data.length === 0) {
        return fail(404, { error: true, message: `Project not found or no changes applied for Orders ID: ${clientOrdersId}` })
      }

      console.log("Project updated successfully:", data)
      return { success: true, message: "Project updated successfully!", project: data[0] }
    } catch (err) {
      console.error("Update action error:", err)
      return fail(500, { error: true, message: `An unexpected error occurred: ${err.message}` })
    }
  },

  delete: async ({ request }) => {
    console.log('deleting.. (server-side)'); // This log will now appear when action is hit
    try {
      const formData = await request.formData()
      // The 'id' from formData now represents the 'orders' primary key value
      const clientOrdersId = formData.get("id")?.toString()

      if (!clientOrdersId) {
        return fail(400, { error: true, message: "Project ID (orders) is required for deletion." })
      }

      const dbOrdersId = Number(clientOrdersId); // Convert to number for DB query
      if (isNaN(dbOrdersId)) {
          return fail(400, { error: true, message: "Invalid project ID (orders) format. Must be a number." });
      }

      // Delete project by 'orders' primary key
      const { data, error: deleteError } = await supabaseServer.from("projects").delete().eq("orders", dbOrdersId).select() // FIX: Use 'orders' for filtering

      if (deleteError) {
        console.error("Delete error:", deleteError)
        return fail(500, { error: true, message: `Failed to delete project: ${deleteError.message}` })
      }

      if (!data || data.length === 0) {
        return fail(404, { error: true, message: `Project not found for Orders ID: ${clientOrdersId}` })
      }

      console.log("Project deleted successfully:", data)
      return { success: true, message: "Project deleted successfully!" }
    } catch (err) {
      console.error("Delete action error:", err)
      return fail(500, { error: true, message: `An unexpected error occurred: ${err.message}` })
    }
  },
}
